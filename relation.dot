digraph {
  // weakly polynomial
  convex_programming -> linear_programming;
  lp_type -> linear_programming;
  violator_space -> lp_type;
  // optimization problems
  min_cost_multi_commodity_transshipment [label="minimum cost multi-commodity transshipment"];
  max_flow [label="maximum flow"];
  weighted_bipartite_matching [label="weighted bipartite matching"];
  bipartite_matching [label="bipartite matching"];
  min_cost_max_flow [label="minimum cost maximum flow"];
  shortest_path_nonneg_weight [label="non-negative weighted shortest path"]
  shortest_path_weight [label="weighted shortest path"];
  shortest_path [label="shortest path"];
  min_cost_max_bipartite_matching [label="minimum cost maximum weight bipartite matching"];
  weighted_matching [label="maximum weight matching"];
  min_cost_perfect_matching [label="minimum cost perfect matching"];

  submodular_flow [label="submodular flow"];
  polymatroid_intersection [label="polymatroid intersection"];
  linear_programming [label="linear programming"];
  all_pairs_shortest_path [label="all pairs shortest path"];
  min_cost_flow [label="minimum cost flow"];
  min_cost_trans [label="minimum cost transshipment"];
  degree_constrained_orientation [label="degree constrained orientation"];
  max_flow_int [label="maximum flow with integer weights"];
  submodular_min [label="submodular minimization"];
  symmetric_submodular_min [label="symmetric submodular minimization"];

  
  submodular_flow -> degree_constrained_k_edge_connected_orientation;
  degree_constrained_k_edge_connected_orientation -> k_edge_connected_orientation;
  degree_constrained_k_edge_connected_orientation -> degree_constrained_orientation;
  submodular_flow -> min_cost_max_flow;
  submodular_min -> symmetric_submodular_function_hereditary;
  submodular_min -> directed_min_cut;
  symmetric_submodular_function_hereditary -> symmetric_submodular_min;
  symmetric_submodular_min -> hypergraph_min_cut;
  hypergraph_min_cut -> min_cut;
  min_cost_multi_commodity_transshipment -> min_cost_trans;
  min_cost_multi_commodity_transshipment -> all_pairs_shortest_path;
  min_cost_trans -> max_flow;
  max_flow -> max_flow_int;
  min_cost_max_flow -> weighted_bipartite_matching;
  weighted_bipartite_matching -> bipartite_matching;
  max_flow_int -> bipartite_matching;
  min_cost_max_flow -> max_flow;
  min_cost_trans  -> min_cost_flow;
  min_cost_flow -> shortest_path_weight;
  submodular_flow -> polymatroid_intersection;
  linear_programming -> submodular_flow;
  linear_programming -> min_cost_multi_commodity_transshipment;
  shortest_path_weight -> shortest_path_nonneg_weight;
  shortest_path_nonneg_weight -> shortest_path;
  max_flow_int -> degree_constrained_orientation;
  degree_constrained_orientation -> bipartite_matching;
  degree_constrained_orientation -> eulerian_orientation;
  min_cost_perfect_matching -> weighted_matching;
  weighted_matching -> weighted_bipartite_matching;
  
  degree_constrained_subgraphs -> b_matching;
  b_matching-> bipartite_b_matching;
  bipartite_b_matching->weighted_bipartite_matching;
  
  min_cost_flow -> shortest_s_t_cycle;
  
  // scheduling
  //single_machine_total_weighted_completion_time; // greedy
   //Minimizing Makespan with Preemptions on N machines, polytime
   //Qm | prmp | Cmax
   //Qm | rj,prmp | Cmax
   //Pm || sum Cj
   //Qm | prmp | sum Cj 
   //Qm | prmp | Lmax
   //F2 || Cmax
   //F2 | block | Cmax 
   //J2 || Cmax
   //O2 || Cmax 
   // Om | prmp | Cmax
   // Om | prmp | Lmax
   //Om | rj,pij = 1 | Cmax
  // matroids
  polymatroid_intersection [label="polymatroid intersection"];
  polymatroid_optimization [label="polymatroid optimization"];
  minimum_spanning_arborescence [label="minimum spanning arborescence"];
  matroid_optimization [label="matroid optimization"];
  matroid_intersection [label="matriod intersection"];
  minimum_spanning_tree [label="minimum spanning tree"];
  matriod_partition [label="matriod partition"];
  forest_decomposition [label="forest decomposition"];
  minimum_spanning_arborescence [label="minimum spanning arborescence"];
  rooted_k_edge_connection [label="rooted $k$-edge-connection"];
  
  polymatroid_intersection -> polymatroid_optimization;
  polymatroid_intersection -> matroid_intersection;
  polymatroid_optimization -> matroid_optimization;
  matroid_intersection -> matroid_optimization -> minimum_spanning_tree; 
  matroid_intersection -> weighted_bipartite_matching;
  matroid_intersection -> rooted_k_edge_connection;
  matriod_intersection -> matriod_union_independence_oracle;
  matriod_union_independence_oracle -> matriod_partition -> forest_decomposition;
  matriod_partition->maximum_density_subgraph;
  rooted_k_edge_connection -> minimum_spanning_arborescence;
  minimum_spanning_arborescence -> minimum_spanning_tree;

  eulerian_orientation [label="eulerian orientation"];
  directed_min_cut [label="global directed minimum cut"];
  min_cut [label="global minimum cut"];
  edge_connectivity [label="edge connectivity"];
  directed_min_cut -> min_cut;
  min_cut -> edge_connectivity;

  // String matching problems
  exact_string_matching [label="exact string matching"];
  n_dimensional_pattern_matching [label="n dimensional pattern matching"];
  exact_string_matching_with_dont_cares [label="exact string matching with don't cares"];
  regular_expression_matching [label="regular expression matching"];
  regular_expression_substring_matching [label="regular expression substring matching"];
  regular_expression_substring_matching -> exact_string_matching_with_dont_cares;
  regular_expression_substring_matching -> regular_expression_matching;
  exact_string_matching_with_dont_cares -> exact_string_matching;
  n_dimensional_pattern_matching -> exact_string_matching;

  // DP
  generic_shortest_path_superior [label="generic shortest path superior"];
  generic_shortest_path_dag [label="generic shortest path for DAGs"];
  count_paths_dag [label="number of paths in a DAG"];
  longest_path_dag [label="longest path in a DAG"];
  
  widest_path [label="widest path problem"];
  undirected_widest_path [label="undirected widest path problem"];
  
  generic_shortest_path_superior -> widest_path;
  widest_path -> undirected_widest_path;
  //all_pairs_widest_path;
  minimum_spanning_tree -> undirected_widest_path;
  generic_shortest_path_superior -> shortest_path_nonneg_weight;
  generic_shortest_path_dag -> count_paths_dag;
  generic_shortest_path_dag -> longest_path_dag;
  
  // Sequence Alignment
  cyclic_alignment -> global_alignment;
  cyclic_alignment -> cyclic_longest_common_subsequence;
  alignment_boundary -> global_alignment;
  local_alignment;
  tree_edit_distance -> levenshtein_distance;
  global_alignment -> levenshtein_distance -> longest_common_subsequence;
  alignment_boundary -> fitting_alignment;
  alignment_boundary -> overlapping_alignment -> semiglobal_alignment;
  fitting_alignment -> exact_string_matching_with_dont_cares;
  exact_string_matching -> cyclic_string_equivalence;
  cyclic_longest_common_subsequence -> longest_common_subsequence -> longest_increasing_subsequence
  longest_common_subsequence -> shortest_common_supersequence;
  
  // Done
  // sequential knapsack
  
  // Todo
  // Modular decomposition http://en.wikipedia.org/wiki/Modular_decomposition
  // reconize total unimodularity 
  // stable matching(bipartite), egalitarian(maximum weight), minimum regret, stable roommate problem.
  // tree isomorphism
  // k-cores

  // The Generalized Distributive Law
  // http://cstheory.stackexchange.com/questions/750/have-any-generalizations-of-maximum-weight-matching-been-studied
  //longest_alternating_subsequence
}